---
layout: post
title:  paper reading-面向国产申威 26010 众核处理器的 SpMV 实现与优化
keywords: SpMV, SW
categories : paper
tags:
  - paper
---


## 摘要
1.针对申威处理器提出了一种 CSR 格式 SpMV 操作的通用异构众核并行算法,
该算法从任务划分、 LDM 空间划分方面进行精细设计,提出了一套动静态 buffer 的缓存机制以提升向量 x 的访存
命中率,提出了一套动静态的任务调度方法以实现负载均衡.另外还分析了该算法中影响 SpMV 性能的几个关键因
素,并开展了自适应优化,进一步提升了性能。

2.相比主核版最高有 10 倍左右加速,平均加速比为 6.51.通过采用主核版 CSR 格式 SpMV 的访存量进行分析,
测试矩阵最高可达该处理器实测带宽的 86%,平均可达到 47%。


3.spmv优化的挑战有：
（1）SpMV 属于访存密集型的,算法中的浮点计算与存储访问的比率很低；（在sw平台上，访存墙问题更加突出,使得带宽受
限型操作的峰值性能也越来越低, 实现难度增大）

（2）且稀疏矩阵非零元素分布很不规则,使得向量 x 为间接访问且访问不规则,可重用性差。

## 算法描述

从任务划分、 LDM 空间划分、向量 x 访存优化（我的没有）、负载均衡、自适应优化等角度开展工作。

1.任务划分

对于稀疏矩阵而言,任务划分方法有两种:一维划分和二维划分.二维划分时多个从核会同时更新 y 向量的
一部分,需要加锁处理,从而导致额外的开销.对规则稀疏矩阵而言,每行的非零元个数较少,LDM 可以容纳至少
一行计算所需的元素,所以我们采用一维的任务划分方法。

一维划分的两种划分方式，如下图所示：![](/images/paper/spmv-sw-lff-1.png)



2.LDM空间划分

CSR 格式的 SpMV 计算需要 val,colIndex,rowIndex,x,y 5 个数组的值才能完成（srow为每次可以处理的行块的行数）：

（1）y 的空间只需 srow 大小；
（2）rowIndex 数组类似,只需srow 1大小；
（3）40KB 用于存放 val 和 col；
（4）x的设置2 块 buffer,一块静态 buffer,其大小为 xssize 和一块动态 buffer,其大小为 xdsize.静态 buffer 加载一次后重复使用;动态 buffer 在静态 buffer 没有命中时使用,如没有命中则从当前所需的 x 处加载 xdsize 个数据到动态buffer,后续计算时先查找静态 buffer,再查找动态 buffer,如果没有命中,继续加载 xdsize 个数据到动态 buffer 中。如下图所示：
![](/images/paper/spmv-sw-lff-2.png)

## 实现与优化

1.x访存优化

2.负载均衡

算法描述部分的静态划分方式会导致负载不均衡的原因如下：

（1）每个从核计算的行块的总非零元个数可能差异较大
（2）每个从核计算的行块中 x 的访存行为可能差异较大

而动态调度的方式需要使用原子指令来实现。该原子指令需要每次都访问主存，也有一定的开销。故，对于spmv的多次迭代，本文采用如下方式处理：

第一次迭代采用原子操作来进行动态任务划分，并把每个从核处理的任务记录下来。接下来的迭代中，每个从核按照记录，执行自己的任务集。（相比每次都动态分配，10%-40%的性能提升）

3.自适应优化

4.双缓冲优化

如下图所示：
![](/images/paper/spmv-sw-lff-db.png)

## 总结



## 我的收获
1.LDM访问x时动静态的设计方案相当于模拟了最简单的cache的1,2级缓存机制。（思路不错！）

2.




    